# 通過堆進行信息泄漏

## 什麼叫信息泄漏
在CTF中，Pwn題目一般都是運行在遠端服務器上的。因此我們不能獲知服務器上的libc.so地址、Heap基地址等地址信息，但是在進行利用的時候往往需要這些地址，此時就需要進行信息泄漏。

## 信息泄漏的目標
信息泄漏的目標有哪些？我們可以通過觀察內存空間來獲知這一點

```
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-x /home/pwn
0x0000000000600000 0x0000000000601000 0x0000000000000000 r-- /home/pwn
0x0000000000601000 0x0000000000602000 0x0000000000001000 rw- /home/pwn
0x0000000000602000 0x0000000000623000 0x0000000000000000 rw- [heap]
0x00007ffff7a0d000 0x00007ffff7bcd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.23.so
0x00007ffff7bcd000 0x00007ffff7dcd000 0x00000000001c0000 --- /lib/x86_64-linux-gnu/libc-2.23.so
0x00007ffff7dcd000 0x00007ffff7dd1000 0x00000000001c0000 r-- /lib/x86_64-linux-gnu/libc-2.23.so
0x00007ffff7dd1000 0x00007ffff7dd3000 0x00000000001c4000 rw- /lib/x86_64-linux-gnu/libc-2.23.so
0x00007ffff7dd3000 0x00007ffff7dd7000 0x0000000000000000 rw- 
0x00007ffff7dd7000 0x00007ffff7dfd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/ld-2.23.so
0x00007ffff7fdb000 0x00007ffff7fde000 0x0000000000000000 rw- 
0x00007ffff7ff6000 0x00007ffff7ff8000 0x0000000000000000 rw- 
0x00007ffff7ff8000 0x00007ffff7ffa000 0x0000000000000000 r-- [vvar]
0x00007ffff7ffa000 0x00007ffff7ffc000 0x0000000000000000 r-x [vdso]
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000025000 r-- /lib/x86_64-linux-gnu/ld-2.23.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x0000000000026000 rw- /lib/x86_64-linux-gnu/ld-2.23.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw- 
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
```
首先第一個是主模塊的基地址，因爲只有在開啓PIE(地址無關代碼)的情況下主模塊的基地址纔會發生改變，因此通常情況下主模塊的地址不需要泄漏。
第二個是堆地址，堆地址對於進程來說是每次運行都會改變，當然需要控制堆中的數據時可能就需要先泄漏堆基地址。
第三個是libc.so的地址，在很多情況下我們只有通過libc中的system等函數才能實現代碼執行，並且malloc_hook、one_gadgets、IO_FILE等結構也都儲存在libc中，因此libc的地址也是我們泄漏的目標。

## 通過什麼進行泄漏
通過前面的知識我們知道heap分爲unsorted bin、fastbin、smallbin、large bin等，我們逐個考察這些結構來查看如何進行泄漏。

## unsorted bin
我們構造兩個unsorted bin然後查看它的內存，現在在unsorted bin鏈表中存在兩個塊，第一個塊的地址是0x602000、第二個塊的地址是0x6020f0

```
0x602000:	0x0000000000000000	0x00000000000000d1
0x602010:	0x00007ffff7dd1b78	0x00000000006020f0 <=== 指向下一個塊
0x602020:	0x0000000000000000	0x0000000000000000
0x602030:	0x0000000000000000	0x0000000000000000
```

```
0x6020f0:	0x0000000000000000	0x00000000000000d1
0x602100:	0x0000000000602000	0x00007ffff7dd1b78 <=== 指向main_arena
0x602110:	0x0000000000000000	0x0000000000000000
0x602120:	0x0000000000000000	0x0000000000000000
```
因此我們知道通過unsorted bin我們可以獲取到某個堆塊的地址和main_areana的地址。一旦獲取到某個堆塊的地址就可以通過malloc的size進行計算從而獲得堆基地址。一旦獲取到main_arena的地址，因爲main_arena存在於libc.so中就可以計算偏移得出libc.so的基地址。
因此，通過unsorted bin可以獲得：1.libc.so的基地址 2.heap基地址

## fastbin
我們構造了兩個fastbin然後查看它們的內存，現在在fastbin鏈表中存在兩個塊，第一個塊的地址是0x602040，第二個塊的地址是0x602000

```
0x602000:	0x0000000000000000	0x0000000000000021
0x602010:	0x0000000000000000	0x0000000000000000
```

```
0x602040:	0x0000000000000000	0x0000000000000021
0x602050:	0x0000000000602000 	0x0000000000000000 <=== 指向第一個塊
```
根據前面的知識我們知道fastbin鏈表最末端的塊fd域爲0，此後每個塊的fd域指向前一個塊。因此通過fastbin只能泄漏heap的基地址

## smallbin
我們構造了兩個fastbin然後查看它們的內存，現在在fastbin鏈表中存在兩個塊，第一個塊的地址是0x602000，第二個塊的地址是0x6020f0
```
0x602000:	0x0000000000000000	0x00000000000000d1
0x602010:	0x00007ffff7dd1c38	0x00000000006020f0 <=== 下一個塊的地址
0x602020:	0x0000000000000000	0x0000000000000000
0x602030:	0x0000000000000000	0x0000000000000000
```

```
0x6020f0:	0x0000000000000000	0x00000000000000d1
0x602100:	0x0000000000602000	0x00007ffff7dd1c38 <=== main_arena的地址
0x602110:	0x0000000000000000	0x0000000000000000
0x602120:	0x0000000000000000	0x0000000000000000
```
因此，通過smallbin可以獲得：1.libc.so的基地址 2.heap基地址

## 哪些漏洞可以用於泄漏
通過前面的知識我們可以獲知堆中存在哪些地址信息，但是想要獲取到這些地址需要通過漏洞來實現
一般來說以下漏洞是可以進行信息漏洞的

* 堆內存未初始化
* 堆溢出
* Use-After-Free
* 越界讀
* heap extend 

###  0x01 read UAF

通過，UAF ，泄露 heapbase：

```c
p0 = malloc(0x20);
p1 = malloc(0x20);

free(p0);
free(p1);
    
printf('heap base:%p',*p1);
```

 由於 fastbin list 的特性，當我們構造一條fastbin list的時候

```bash
(0x30)     fastbin[1]: 0x602030 --> 0x602000 --> 0x0
```

存在 chunk 1 -> chunk 0 的現象，如果此時 UAF漏洞存在，我們可以通過 show chunk 1，將chunk 0的地址打印出來



同理，泄露 libc base

```c
p0 = malloc(0x100);
free(p0);
printf("libc: %p\n", *p0);

```



### 0x02  overlapping chunks





### 0x03 Partial Overwrite



### 0x04 Relative Write